'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.handleRequestComplete = exports.isJson = undefined;

var _ramda = require('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

var _jsUtil = require('js-util');

var util = _interopRequireWildcard(_jsUtil);

var _errors = require('./errors');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Determines whether the given string is JSON.
 *
 * @param {string} text: The string to example.
 * @return {boolean}
 */
var isJson = exports.isJson = function isJson(text) {
  if (_ramda2.default.isNil(text) || _ramda2.default.isEmpty(text)) {
    return false;
  }
  if (text.startsWith('{') && text.endsWith('}')) {
    return true;
  }
  if (text.startsWith('[') && text.endsWith(']')) {
    return true;
  }
  return false;
};

/**
 * Handles a completed HTTP request.
 *
 * @param {integer} status: The HTTP status code.
 * @param {string} responseText: The raw text returned within the response.
 * @param {string} statusText: The text describing the status
 * @param {object} responseHeaders: An object containing the reponse headers.
 * @param {function} resolve: The Promise's success callback.
 * @param {function} reject: The promise's error callback.
 */
var handleRequestComplete = exports.handleRequestComplete = function handleRequestComplete(status, statusText, responseText, responseHeaders, resolve, reject) {
  if (status !== 200) {
    // Failed.
    reject(new _errors.HttpError(status, responseText, statusText));
  } else {
    // Success.
    var response = responseText;
    if (isJson(response)) {
      try {
        response = JSON.parse(response);
      } catch (err) {
        reject(new _errors.HttpParseError(responseText, err));
        return;
      }
    } else if (response === 'true' || response === 'false') {
      response = util.toBool(response);
    } else if (util.isNumeric(response)) {
      response = parseFloat(response);
    }
    resolve({ data: response, headers: responseHeaders });
  }
};
//# sourceMappingURL=shared.js.map