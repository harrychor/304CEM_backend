"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var _util = require("../util");

var _color = require("../color");

var color = _interopRequireWildcard(_color);

/**
 * Takes an image path and breaks it into it's components pieces
 * providing 1x/2x versions of the image.
 *
 * @param {string} path: the raw file path to evaluate.
 * @return {object}
 */
var expandImagePath = function expandImagePath(path) {
  if (_lodash2["default"].isEmpty(path)) {
    throw new Error("Image path not specified.");
  }

  // Extract paths and file-name.
  var index = _lodash2["default"].lastIndexOf(path, "/");
  var basePath = path.substr(0, index + 1);
  var fileName = path.substr(index + 1, path.length);
  var parts = fileName.split(".");
  if (parts.length < 2) {
    throw new Error("An image must have a file extension. [path: " + path + "]");
  }
  fileName = parts[0];
  var extension = parts[1];

  // Finish up.
  return {
    basePath: basePath,
    fileName: fileName,
    extension: extension,
    "1x": "" + basePath + fileName + "." + extension,
    "2x": "" + basePath + fileName + "@2x." + extension
  };
};

exports.expandImagePath = expandImagePath;
/**
 * Constructs a style object for an image.
 *
 *    For turning image files (PNG/JPG/SVG) into data-uri's see:
 *    https://github.com/webpack/url-loader
 *
 * @param {string} image1x: The normal image resolution (base64 encoded)
 * @param {string} image2x: The retina image resolution (base64 encoded)
 * @param {integer} width: Optional. The width of the image.
 * @param {integer} height: Optional. The height of the image.
 */
var image = function image(image1x, image2x) {
  var _ref = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

  var _ref$width = _ref.width;
  var width = _ref$width === undefined ? 10 : _ref$width;
  var _ref$height = _ref.height;
  var height = _ref$height === undefined ? 10 : _ref$height;

  // Prepare image based on current screen density.
  var img = global.devicePixelRatio > 1 ? image2x : image1x;
  if (!img) {
    img = image1x;
  }
  if (!img) {
    throw new Error("Must have at least a 1x image.");
  }

  // Finish up.
  return {
    backgroundImage: "url(" + img + ")",
    width: width,
    height: height,
    backgroundSize: width + "px " + height + "px",
    backgroundRepeat: "no-repeat"
  };
};

exports.image = image;
var mergeAndReplace = function mergeAndReplace(key, value, target) {
  _lodash2["default"].merge(target, value);
  delete target[key];
  return target;
};

var formatImage = function formatImage(key, value, target) {
  // Wrangle parameters.

  var _value = _slicedToArray(value, 4);

  var image1x = _value[0];
  var image2x = _value[1];
  var width = _value[2];
  var height = _value[3];

  if (_lodash2["default"].isNumber(image2x)) {
    height = width;
    width = image2x;
    image2x = undefined;
  }
  var style = image(image1x, image2x, { width: width, height: height });
  mergeAndReplace(key, style, target);
};

// ----------------------------------------------------------------------------

var toPositionEdges = function toPositionEdges(key, value) {
  if (value === undefined || value === null) {
    return undefined;
  }
  if (_lodash2["default"].isString(value) && (0, _util.isBlank)(value)) {
    return undefined;
  }
  if (_lodash2["default"].isArray(value) && value.length === 0) {
    return undefined;
  }
  if (!_lodash2["default"].isArray(value)) {
    value = value.toString().split(" ");
  }
  var edges = value.map(function (item) {
    return (0, _util.toNumber)(item);
  });
  var top = undefined,
      right = undefined,
      bottom = undefined,
      left = undefined;

  var getEdge = function getEdge(index) {
    var edge = edges[index];
    if (_lodash2["default"].isNull(edge) || edge === "null" || edge === "") {
      return undefined;
    }
    return edge;
  };

  switch (edges.length) {
    case 1:
      top = getEdge(0);
      bottom = getEdge(0);
      left = getEdge(0);
      right = getEdge(0);
      break;

    case 2:
      top = getEdge(0);
      bottom = getEdge(0);
      left = getEdge(1);
      right = getEdge(1);
      break;

    case 3:
      top = getEdge(0);
      left = getEdge(1);
      right = getEdge(1);
      bottom = getEdge(2);
      break;

    default:
      top = getEdge(0);
      right = getEdge(1);
      bottom = getEdge(2);
      left = getEdge(3);
  }

  if (top === undefined && right === undefined && bottom === undefined && left === undefined) {
    return undefined;
  } else {
    return {
      position: key.toLowerCase(),
      top: top, right: right, bottom: bottom, left: left
    };
  }
};

exports.toPositionEdges = toPositionEdges;
var formatPositionEdges = function formatPositionEdges(key, target) {
  var styles = toPositionEdges(key, target[key]);
  mergeAndReplace(key, styles, target);
};

var formatAbsoluteCenter = function formatAbsoluteCenter(key, value, target) {
  if (value === true) {
    value = "xy";
  }
  if (value === false || value === undefined || value === null) {
    return;
  }
  var styles = { position: "absolute" };
  value = value.trim().toLowerCase();
  if (value.includes("x")) {
    styles.left = "50%";
  }
  if (value.includes("y")) {
    styles.top = "50%";
  }
  var transform = undefined;
  switch (value) {
    case "yx":
    case "xy":
      transform = "translate(-50%, -50%)";break;
    case "x":
      transform = "translateX(-50%)";break;
    case "y":
      transform = "translateY(-50%)";break;
    default:
      throw new Error("AbsoluteCenter value \"" + value + "\" not supported.");
  }
  styles.transform = ((target.transform || "") + " " + transform).trim();
  mergeAndReplace(key, styles, target);
};

// ----------------------------------------------------------------------------

/**
 * Helpers for constructing a CSS object.
 * @param {object} styles: The style object to manipulate.
 * @return the resulting style object.
 */
var css = function css() {
  var styles = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

  _lodash2["default"].keys(styles).forEach(function (key) {
    var value = styles[key];
    if (_lodash2["default"].isUndefined(value) || _lodash2["default"].isNull(value)) {
      delete styles[key];
    } else if (_lodash2["default"].isPlainObject(value)) {
      styles[key] = css(value); // <== RECURSION.
    } else {
        switch (key) {
          case "Image":
            formatImage(key, value, styles);break;
          case "Absolute":
            formatPositionEdges(key, styles);break;
          case "Fixed":
            formatPositionEdges(key, styles);break;
          case "AbsoluteCenter":
            formatAbsoluteCenter(key, value, styles);break;
        }
      }
  });

  // Finish up.
  return styles;
};

// ----------------------------------------------------------------------------
css.image = image;
_lodash2["default"].merge(css, color);
exports["default"] = css;