"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _lodash = require("lodash");

var _lodash2 = _interopRequireDefault(_lodash);

var extractDescription = function extractDescription(lines) {
  var description = [];
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = _lodash2["default"].clone(lines)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var line = _step.value;

      line = line.trim();
      if (_lodash2["default"].startsWith(line, "@param") || _lodash2["default"].startsWith(line, "@return")) {
        break;
      }
      description.push(line);
      lines.shift();
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator["return"]) {
        _iterator["return"]();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return description.join("\n").replace(/\n*$/, "");
};

var extractParameters = function extractParameters(lines) {
  var current = undefined;
  var params = {};

  var _iteratorNormalCompletion2 = true;
  var _didIteratorError2 = false;
  var _iteratorError2 = undefined;

  try {
    for (var _iterator2 = _lodash2["default"].clone(lines)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
      var line = _step2.value;

      line = line.trim();
      if (_lodash2["default"].startsWith(line, "@return")) {
        break;
      }

      // Is this the start of a new parameter?
      if (_lodash2["default"].startsWith(line, "@param")) {
        line = line.replace(/^\@param/, "").trim();

        // Get the type details.
        var match = line.match(/\{.*\}/);
        var type = undefined;
        if (match) {
          type = match[0].replace("{", "").replace("}", "").trim();
          line = line.substring(match[0].length, line.length).trim();
        }

        // Get the parameter name.
        var index = line.indexOf(" ");
        var _name = line.substring(0, index).replace(/\:$/, "").trim();
        line = line.substring(index, line.length).trim().replace("-", "").trim();

        // Store state.
        current = undefined;
        if (_name) {
          current = _name;
          params[current] = { name: _name, description: "" };
          if (type) {
            params[current].type = type;
          }
        }
      }

      // Append the parameter description.
      if (current) {
        var description = (params[current].description + (" " + line)).trim();
        params[current].description = description;
        lines.shift();
      }
    }

    // Finish up.
  } catch (err) {
    _didIteratorError2 = true;
    _iteratorError2 = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion2 && _iterator2["return"]) {
        _iterator2["return"]();
      }
    } finally {
      if (_didIteratorError2) {
        throw _iteratorError2;
      }
    }
  }

  return params;
};

/**
 * Represents the documentation details for a method.
 */

var MethodDocs =
/**
 * Constructor
 * @param {string} raw: The raw documentation string for the method.
 */
function MethodDocs(raw) {
  _classCallCheck(this, MethodDocs);

  this.params = {};
  if (!_lodash2["default"].isEmpty(raw)) {
    var lines = raw.split("\n");
    this.description = extractDescription(lines);
    this.params = extractParameters(lines);
  }
};

exports["default"] = MethodDocs;
module.exports = exports["default"];